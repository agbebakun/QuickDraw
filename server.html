<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="data:;base64,">
<title>Quick Draw!</title>
<style>
body {
	font-family: sans-serif;
}
canvas {
	border: 1px solid black;
	touch-action: none; /* Prevent scrolling on touch devices while drawing */
	margin-top: 1em;
}
.hidden {
	display: none;
}
</style>
</head>
<body>
<h1>Welcome to Quick Draw!</h1>

<!-- Test form to get classes -->
<!--
<form action="/classes" method="get">
	<input type="submit" value="Get Classes">
</form>
-->

<!-- Test form to upload an image file -->
<!--
<form action="/classify_image" method="post" enctype="multipart/form-data">
	<label for="file">Choose an image to upload:</label>
	<input type="file" name="image" accept="image/*" required>
	<input type="submit" value="Upload Image">
</form>
-->

<div class="instructions">-</div>
<div class="drawing">
	<canvas></canvas>
</div>
<div class="controls">
	<button id="clearButton">Clear</button>
	<button id="classifyStrokesButton">Check</button>
	<button class="hidden" id="classifyImageButton">Check from Image</button>
	<button id="nextButton">Next</button>
</div>
<div id="results"></div>

<script>
// Config
const USE_LOCAL_RECOGNIZER = true;
const CANVAS_SIZE = 512;
const LINE_WIDTH = 4;

// State
const strokes = [];		// Array to hold strokes (each stoke is an array of points, each point is an [x, y] pair)
let is_drawing = false;
let drawing_class = null;
let classes = [];		// Fetch from server


// --- LOCAL RECOGNIZER ---
const IMAGE_SIZE = 28;
let recognizer = null;

// Sample input
function randomImage() {
	const data = [];
	for (let y = 0; y < IMAGE_SIZE; y++) {
		for (let x = 0; x < IMAGE_SIZE; x++) {
			data.push(Math.random());
		}
	}
	return data;
}

// use an async context to call onnxruntime functions.
async function recognize(data = null) {
	if (!window.onnxRecognizerPromise) {
		// Dynamically load recognizer script
		window.onnxRecognizerPromise = new Promise((resolve, reject) => {
			const script = document.createElement('script');
			script.src = './onnx-recognizer.js';
			script.onload = async () => {
				recognizer = new OnnxRecognizer(
					"./trained_models/whole_model_quickdraw.onnx",
					[1, 1, IMAGE_SIZE, IMAGE_SIZE],
					'input',
					'linear_2'
				);
				console.log("Loading ONNX library and model...");
				await recognizer.load();
				// Debug: additional delay to test waiting for async load
				//await new Promise(r => setTimeout(r, 5 * 1000));
				console.log("ONNX model loaded.");
				resolve();
			}
			script.onerror = reject;
			document.head.appendChild(script);
		});
	}
	await window.onnxRecognizerPromise;

	if (!data) {
		return null;
	}

	console.log("Running recognition...");
	const output = await recognizer.recognize(data);
	// console.log("Recognition output:", output);

	// Softmax
	const softmax = recognizer.softmax(output);
	// console.log("Softmax output:", softmax);

	// Ordered results
	orderedIndices = recognizer.orderedIndices(softmax);
	// console.log("Ordered indices:", orderedIndices);
	// for (let i = 0; i < orderedIndices.length; i++) {
	// 	const idx = orderedIndices[i];
	// 	console.log(`Class ${idx}: Probability ${softmax[idx]}`);
	// }

	// Maximum index
	const maxIndex = recognizer.maxIndex(softmax);

	return {
		output,
		softmax,
		orderedIndices,
		maxIndex,
	};
}

// Draw strokes to small image
function draw_to_canvas(strokes, pen_size = 1) {
	// Find min and max coordinates
	let min_x = null;
	let min_y = null;
	let max_x = -null;
	let max_y = -null;
	for (const stroke of strokes) {
		for (const point of stroke) {
			const [x, y] = point;
			if (min_x === null || x < min_x) min_x = x;
			if (min_y === null || y < min_y) min_y = y;
			if (max_x === null || x > max_x) max_x = x;
			if (max_y === null || y > max_y) max_y = y;
		}
	}

	// Check if valid
	if (min_x === null || min_y === null || max_x === null || max_y === null) {
		return null; // No strokes
	}
	if (max_x <= min_x || max_y <= min_y) {
		return null; // Invalid strokes
	}

	// Add some padding
	const padding = pen_size * 2;

	// Create canvas
	const canvas = document.createElement("canvas");
	canvas.width = IMAGE_SIZE;
	canvas.height = IMAGE_SIZE;

	// Scale
	const scale_x = (canvas.width - padding * 2) / (max_x - min_x);
	const scale_y = (canvas.height - padding * 2) / (max_y - min_y);
	const scale = Math.min(scale_x, scale_y);

	// Offset to center
	const offset_x = (canvas.width - (max_x - min_x) * scale) / 2;
	const offset_y = (canvas.height - (max_y - min_y) * scale) / 2;

	// Drawing parameters
	const ctx = canvas.getContext("2d");
	ctx.fillStyle = "black";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.strokeStyle = "white";
	ctx.lineCap = "round";
	ctx.lineJoin = "round";
	ctx.lineWidth = pen_size;

	// Draw strokes
	for (const stroke of strokes) {
		if (stroke.length === 0) continue;
		ctx.beginPath();
		const [first_x, first_y] = stroke[0];
		ctx.moveTo(
			(first_x - min_x) * scale + offset_x,
			(first_y - min_y) * scale + offset_y
		);
		for (let i = 1; i < stroke.length; i++) {
			const [x, y] = stroke[i];
			ctx.lineTo(
				(x - min_x) * scale + offset_x,
				(y - min_y) * scale + offset_y
			);
		}
		ctx.stroke();
	}

	return canvas;
}

function canvas_to_image_url(canvas) {
	if (!canvas) return null;
	return canvas.toDataURL("image/png");
}

function canvas_to_image_data(canvas) {
	if (!canvas) return null;
	const imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
	// Greyscale to array of exact size
	const data = new Array(IMAGE_SIZE * IMAGE_SIZE);
	for (let y = 0; y < IMAGE_SIZE; y++) {
		for (let x = 0; x < IMAGE_SIZE; x++) {
			const index = (y * IMAGE_SIZE + x) * 4;
			const r = imageData.data[index + 0];
			const g = imageData.data[index + 1];
			const b = imageData.data[index + 2];
			// Convert to greyscale value (0-1)
			const grey = (r + g + b) / (3 * 255);
			data[y * IMAGE_SIZE + x] = grey;
		}
	}
	return data;
}

// async function test() {
// 	const data = randomImage();
// 	const result = await recognize(data);
// 	console.log(result);
// }
// test();

async function locally_classify_strokes() {
	const canvas = draw_to_canvas(strokes);

	// Output debug image
	if (false) {
		const imageUrl = canvas_to_image_url(canvas);
		if (imageUrl) {
			let debugImage = document.getElementById("debugImage");
			if (!debugImage) {
				debugImage = document.createElement("img");
				debugImage.id = "debugImage";
				document.body.insertBefore(debugImage, document.body.firstChild);
			}
			debugImage.src = imageUrl;
		}
	}

	const imageData = canvas_to_image_data(canvas);
	const result = await recognize(imageData);
	const results = {
		detected_class: !result ? '' : classes[result.maxIndex],
		class_scores: !result ? [] : result.orderedIndices.map(idx => {
			return {
				class: classes[idx],
				score: result.softmax[idx],
			};
		}),
	};

	show_results(results);
}

// ------



let shuffled_classes = [];
function next_drawing() {
	const instructionsDiv = document.querySelector(".instructions");

	// Clear image
	clear();

	// Clear results
	document.getElementById("results").innerHTML = "";

	if (!classes) {
		instructionsDiv.innerHTML = "(Press 'Next' to start)";
		return;
	}

	// If no more shuffled classes are left, reshuffle
	if (!shuffled_classes.length) {
		shuffled_classes = classes.slice();
		// Try to avoid the same class as last time
		for (let retry = 0; retry < 10; retry++) {
			// Shuffle
			for (let i = shuffled_classes.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[shuffled_classes[i], shuffled_classes[j]] = [shuffled_classes[j], shuffled_classes[i]];
			}
			// Check last class
			if (shuffled_classes.length <= 0 || shuffled_classes[0] != drawing_class) break;
		}
	}

	// Remove the first class
	if (shuffled_classes.length > 0) {
		drawing_class = shuffled_classes.shift();
	}

	if (drawing_class) {
		instructionsDiv.innerHTML = `Draw: ${drawing_class}.`;
	} else {
		instructionsDiv.innerHTML = 'Draw one of: ' + classes.join(", ") + '.';
	}
}

function clear() {
	const ctx = document.querySelector("canvas").getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	document.getElementById("results").innerHTML = "";
	strokes.length = 0;
}

function show_results(results) {
	const detected_class = results.detected_class;
	const resultsDiv = document.getElementById("results");
	const correct = detected_class === drawing_class;
	if (!detected_class) {
		resultsDiv.innerHTML = `<h2>Sorry, I could not guess.</h2>`;
	} else if (correct) {
		resultsDiv.innerHTML = `<h2>Correct! I guessed it was: ${detected_class}!</h2>`;
	} else {
		resultsDiv.innerHTML = `<h2>Oops, I thought it was: ${detected_class}.</h2>`;
	}
	let ul = document.createElement("ul");
	results.class_scores.forEach(item => {
		let score = (item.score * 100).toFixed(0);
		if (score > 0) {
			let li = document.createElement("li");
			li.textContent = `${item.class}: ${score}%`;
			ul.appendChild(li);
		}
	});
	resultsDiv.appendChild(ul);
}

async function get_classes() {
	const response = await fetch("./classes.json");
	const result = await response.json();
	console.log("Available classes:", result.classes);
	return result.classes;
}

async function classify_strokes() {
	const response = await fetch("./classify_strokes", {
		method: "POST",
		headers: {
			"Content-Type": "application/json"
		},
		body: JSON.stringify({ strokes: strokes })
	});
	const result = await response.json();
	show_results(result);
	return result;
}

async function classify_image() {
	const canvas = document.querySelector("canvas");
	const dataURL = canvas.toDataURL("image/png");
	const rawData = dataURL.replace(/^data:image\/png;base64,/, "");
	const response = await fetch("./classify_image_data", {
		method: "POST",
		headers: {
			"Content-Type": "application/json"
		},
		body: JSON.stringify({ image: rawData })
	});
	const result = await response.json();
	show_results(result);
	return result;
}

document.querySelector("#clearButton").addEventListener("click", () => clear());
document.querySelector("#classifyStrokesButton").addEventListener("click", () => {
	if (USE_LOCAL_RECOGNIZER) {
		locally_classify_strokes();
	} else {
		classify_strokes();
	}
});
document.querySelector("#classifyImageButton").addEventListener("click", () => classify_image());
document.querySelector("#nextButton").addEventListener("click", () => next_drawing());

function startDrawing(x, y) {
	is_drawing = true;
	strokes.push([[x, y]]);
	// Clear results
	document.getElementById("results").innerHTML = "";
}

function draw(x, y) {
	if (!is_drawing) return;
	const currentStroke = strokes[strokes.length - 1];
	const lastPoint = currentStroke[currentStroke.length - 1];
	const ctx = document.querySelector("canvas").getContext("2d");
	ctx.lineWidth = LINE_WIDTH;
	ctx.lineCap = "round";
	ctx.beginPath();
	ctx.moveTo(lastPoint[0], lastPoint[1]);
	ctx.lineTo(x, y);
	ctx.stroke();
	currentStroke.push([x, y]);

	// Clear results
	document.getElementById("results").innerHTML = "";
}

function stopDrawing() {
	is_drawing = false;

	//classify_strokes();
}

async function run() {
	classes = await get_classes();
	next_drawing();

	const canvas = document.querySelector("canvas");
	canvas.width = CANVAS_SIZE;
	canvas.height = canvas.width;
	canvas.addEventListener("mousedown", (e) => {
		//canvas.setPointerCapture(e.pointerId);
		startDrawing(e.offsetX, e.offsetY);
	});
	canvas.addEventListener("mousemove", (e) => draw(e.offsetX, e.offsetY));
	canvas.addEventListener("mouseup", (e) => {
		stopDrawing();
		//canvas.releasePointerCapture(e.pointerId);
	});
	canvas.addEventListener("mouseout", stopDrawing);
	canvas.addEventListener("touchstart", (e) => {
		//canvas.setPointerCapture(e.pointerId);
		const rect = canvas.getBoundingClientRect();
		const touch = e.touches[0];
		startDrawing(touch.clientX - rect.left, touch.clientY - rect.top);
		e.preventDefault();
	});
	canvas.addEventListener("touchmove", (e) => {
		const rect = canvas.getBoundingClientRect();
		const touch = e.touches[0];
		draw(touch.clientX - rect.left, touch.clientY - rect.top);
		e.preventDefault();
	});
	canvas.addEventListener("touchend", (e) => {
		stopDrawing();
		e.preventDefault();
		//canvas.releasePointerCapture(e.pointerId);
		// If the last stroke had only one point, remove it (to avoid dots)
		if (strokes.length > 0) {
			if (strokes[strokes.length - 1].length <= 1) {
				strokes.pop();
			}
		}
	});

	// In local-recognition mode, preload
	if (USE_LOCAL_RECOGNIZER) {
		await recognize(); // Preload model
	}
}

document.addEventListener("DOMContentLoaded", run);
</script>
</body>
</html>