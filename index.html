<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="data:;base64,">
<title>Quick Draw!</title>
<style>
body {
	font-family: sans-serif;
	width: 100vw;
	width: 100svw;
	height: 100vh;
	height: 100svh;
	background-color: grey;
	margin: 0;
	padding: 0;
	box-sizing: border-box;

	overflow: hidden;
}
.debug_image {
	position: absolute;
	top: 0;
	left: 0;
	width: calc(3 * 28px);
	image-rendering: pixelated;
	border: 1px solid black;
	z-index: 1000;
	box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
	opacity: 0.8;
	/*pointer-events: none;*/
	cursor: pointer;
}
main {
	margin: auto;
	padding: 0;

	display: grid;
	grid-template-rows: auto auto 1fr auto;
	height: 100%;
	width: 100%;
	max-width: 800px;

	background-color: lightgrey;

	overflow: hidden;
}
.heading {
	font-size: 2em;
	font-weight: bold;
	margin-top: 0.5em;
	text-align: center;
}
.heading a {
	color: black;
	text-decoration: underline;
	text-decoration-style: dotted;
}

.controls {
	margin: 1em;

	display: flex;
	flex-direction: row;

	align-items: center;
	justify-content: center;
}

.controls button {
	font-size: 1em;
	margin: 0 0.5em;
	padding: 0.5em 1em;
}

.controls .instructions {
	font-size: 1.2em;
	flex-grow: 1;
	width: 100%;
	text-align: center;
}

.controls .instructions::before {
	content: "\2139\0020";
	font-weight: bold;
}

.controls .instructions .item {
	font-weight: bold;
	font-size: 1.2em;
	white-space: nowrap;
}

.drawing {
	box-sizing: border-box;
	padding: 1em 1em;

	width: 100%;
	height: 100%;
	flex-grow: 1;

	position: relative;
}
.drawing canvas {
	outline: 1px solid black;
	touch-action: none; /* Prevent scrolling on touch devices while drawing */

	/* Take display out of line */
	position: absolute;
	top: 0;
	left: 0;

	width: 100%;
	height: 100%;
	margin: auto;

	background: #fff9b1;
	cursor: crosshair;
}
.results {
	height: 20vh;
	overflow-y: auto;
	width: 100%;
	margin: 0 1em;
}
.error {
	margin: 0.5em 0;
	margin-right: 2em;
	border: 1px solid red;
	border-left: 10px solid red;
	background-color: #ffcccc;
	padding: 0.5em;
	color: darkred;
}
.error::before {
	content: "\26A0\0020";
	font-weight: bold;
}
.hidden {
	display: none;
}
dt {
  display: inline-block;
  width: 4em;
}
dd {
  display: inline;
}
dd::after {
  content: "\A";
  white-space: pre;
}
dialog {
	border: none;
	border-radius: 10px;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	padding: 1em;
	background-color: #f9f9f9;
}
dialog::backdrop {
	background: rgba(0, 0, 0, 0.5);
}
dialog div.dialog_controls {
	text-align: center;
	margin-top: 2cm;
}
dialog button {
	background-color: #4CAF50;
	color: white;
	border: none;
	border-radius: 5px;
	padding: 0.5em 1em;
	cursor: pointer;
	transition: background-color 0.3s;
	font-size: 1.2em;
	padding: 1em;
}
dialog button:hover {
	background-color: #45a049;
}
</style>
</head>
<body>

<main>
<div class="heading">
	<a href="https://github.com/CCAI-CDT/QuickDraw" target="_blank">Quick Draw!</a>
</div>

<!-- Test form to get classes -->
<!--
<form action="/classes" method="get">
	<input type="submit" value="Get Classes">
</form>
-->

<!-- Test form to upload an image file -->
<!--
<form action="/classify_image" method="post" enctype="multipart/form-data">
	<label for="file">Choose an image to upload:</label>
	<input type="file" name="image" accept="image/*" required>
	<input type="submit" value="Upload Image">
</form>
-->

<div class="controls">
	<button id="clearButton">üóëÔ∏è Clear</button>
	<div class="instructions">-</div>
	<button class="hidden" id="classifyStrokesButton">‚ùì Check</button>
	<button class="hidden" id="classifyImageButton">Check from Image</button>
	<button id="nextButton">-</button>
</div>
<div class="drawing">
	<canvas></canvas>
</div>
<div class="results"></div>

<dialog>
<h1>Quick Draw!</h1>
<p>Welcome to <em>Quick Draw!</em></p>
<div class="dialog_controls">
	<button id="start" onclick="this.closest('dialog').close();">Start Drawing!</button>
</div>
</dialog>

</main>
<script>
// Config
const USE_LOCAL_RECOGNIZER = true;
const SHOW_DIALOG = false;
const RESULTS_TOP_K = 6;
const RESULTS_THRESHOLD = 0.001;

// State
let last_error = null;
const strokes = [];		// Completed strokes (each stroke is an array of points, each point is an [x, y] pair)
const activeStrokes = new Map(); // Active strokes keyed by pointerId
let drawing_class = null;
let recognized_class = null;
let classes = [];		// Fetch from server
let classify_mode = false;	// Classify mode for testing

// --- LOCAL RECOGNIZER ---
const IMAGE_SIZE = 28;
let recognizer = null;

// Sample input
function randomImage() {
	const data = [];
	for (let y = 0; y < IMAGE_SIZE; y++) {
		for (let x = 0; x < IMAGE_SIZE; x++) {
			data.push(Math.random());
		}
	}
	return data;
}

// use an async context to call onnxruntime functions.
async function recognize(data = null) {
	if (!window.onnxRecognizerPromise) {
		// Dynamically load recognizer script
		window.onnxRecognizerPromise = new Promise((resolve, reject) => {
			const script = document.createElement('script');
			script.src = './onnx-recognizer.js';
			script.onload = async () => {
				recognizer = new OnnxRecognizer(
					"./trained_models/whole_model_quickdraw.onnx",
					[1, 1, IMAGE_SIZE, IMAGE_SIZE],
					'input',
					'linear_2'
				);
				console.log("Loading ONNX library and model...");
				await recognizer.load();
				// Debug: additional delay to test waiting for async load
				//await new Promise(r => setTimeout(r, 5 * 1000));
				console.log("ONNX model loaded.");
				resolve();
			}
			script.onerror = reject;
			document.head.appendChild(script);
		});
	}
	await window.onnxRecognizerPromise;

	if (!data) {
		return null;
	}
	if (data.data) {	// Directly handle ImageData
		data = data.data;
	}

	console.log("Running recognition...");
	if (data.length !== IMAGE_SIZE * IMAGE_SIZE) {
		throw new Error(`Invalid input data size: expected ${IMAGE_SIZE * IMAGE_SIZE}, got ${data.length}`);
	}
	const output = await recognizer.recognize(data);
	// console.log("Recognition output:", output);

	// Softmax
	const softmax = recognizer.softmax(output);
	// console.log("Softmax output:", softmax);

	// Ordered results
	orderedIndices = recognizer.orderedIndices(softmax);
	// console.log("Ordered indices:", orderedIndices);
	// for (let i = 0; i < orderedIndices.length; i++) {
	// 	const idx = orderedIndices[i];
	// 	console.log(`Class ${idx}: Probability ${softmax[idx]}`);
	// }

	// Maximum index
	const maxIndex = recognizer.maxIndex(softmax);

	return {
		output,
		softmax,
		orderedIndices,
		maxIndex,
	};
}

// Draw strokes canvas
let scale = 1;
let offset_x = 0;
let offset_y = 0;
function draw_to_canvas(canvas, strokes, preserve_canvas) {
	// To allow resizes, strokes are stored relative to a centered maximum-fit square with coordinates from (0,0)-(1,1)

	// Find origin and scale
	scale = Math.min(canvas.width, canvas.height);
	offset_x = (canvas.width / 2) - (scale / 2);
	offset_y = (canvas.height / 2) - (scale / 2);

	// Stroke size is relative to scale
	const pen_size = Math.max(scale * (1/100), 1);

	// Drawing parameters
	const ctx = canvas.getContext("2d");
	if (!preserve_canvas) {
		ctx.fillStyle = "transparent";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}
	ctx.strokeStyle = "black";
	ctx.lineCap = "round";
	ctx.lineJoin = "round";
	ctx.lineWidth = pen_size;

	// Draw strokes
	for (const stroke of strokes) {
		if (stroke.length === 0) continue;
		ctx.beginPath();
		const [first_x, first_y] = stroke[0];
		ctx.moveTo(first_x * scale + offset_x, first_y * scale + offset_y);
		for (let i = 1; i < stroke.length; i++) {
			const [x, y] = stroke[i];
			ctx.lineTo(x * scale + offset_x, y * scale + offset_y);
		}
		ctx.stroke();
	}

	return canvas;
}

function getStrokesIncludingActive() {
	return strokes.concat(Array.from(activeStrokes.values()));
}

// Draw strokes to small image
function rescale_and_draw_to_canvas(strokes, pen_size = 1) {
	// Find min and max coordinates
	let min_x = null;
	let min_y = null;
	let max_x = -null;
	let max_y = -null;
	for (const stroke of strokes) {
		for (const point of stroke) {
			const [x, y] = point;
			if (min_x === null || x < min_x) min_x = x;
			if (min_y === null || y < min_y) min_y = y;
			if (max_x === null || x > max_x) max_x = x;
			if (max_y === null || y > max_y) max_y = y;
		}
	}

	// Check if valid
	if (min_x === null || min_y === null || max_x === null || max_y === null) {
		return null; // No strokes
	}
	if (max_x <= min_x || max_y <= min_y) {
		return null; // Invalid strokes
	}

	// Add some padding
	const padding = pen_size * 2;

	// Create canvas
	const canvas = document.createElement("canvas");
	canvas.width = IMAGE_SIZE;
	canvas.height = IMAGE_SIZE;

	const scale_x = (canvas.width - padding * 2) / (max_x - min_x);
	const scale_y = (canvas.height - padding * 2) / (max_y - min_y);
	const scale = Math.min(scale_x, scale_y);

	// Offset to center
	const offset_x = (canvas.width - (max_x - min_x) * scale) / 2;
	const offset_y = (canvas.height - (max_y - min_y) * scale) / 2;

	// Drawing parameters
	const ctx = canvas.getContext("2d");
	ctx.fillStyle = "black";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.strokeStyle = "white";
	ctx.lineCap = "round";
	ctx.lineJoin = "round";
	ctx.lineWidth = pen_size;

	// Draw strokes
	for (const stroke of strokes) {
		if (stroke.length === 0) continue;
		ctx.beginPath();
		const [first_x, first_y] = stroke[0];
		ctx.moveTo(
			(first_x - min_x) * scale + offset_x,
			(first_y - min_y) * scale + offset_y
		);
		for (let i = 1; i < stroke.length; i++) {
			const [x, y] = stroke[i];
			ctx.lineTo(
				(x - min_x) * scale + offset_x,
				(y - min_y) * scale + offset_y
			);
		}
		ctx.stroke();
	}

	return canvas;
}

function canvas_to_image_url(canvas) {
	if (!canvas) return null;
	return canvas.toDataURL("image/png");
}

async function data_to_image_url(data) {
	const imageData = new ImageData(IMAGE_SIZE, IMAGE_SIZE);
	for (let y = 0; y < IMAGE_SIZE; y++) {
		for (let x = 0; x < IMAGE_SIZE; x++) {
			const si = y * IMAGE_SIZE + x;
			const v = Math.floor(data[si] * 255);
			const di = (y * IMAGE_SIZE + x) * 4;
			imageData.data[di + 0] = v;
			imageData.data[di + 1] = v;
			imageData.data[di + 2] = v;
			imageData.data[di + 3] = 255;
		}
	}
	// Create temporary canvas
	const canvas = document.createElement("canvas");
	canvas.width = imageData.width;
	canvas.height = imageData.height;
	const ctx = canvas.getContext("2d");
	ctx.putImageData(imageData, 0, 0);
	return await canvas.toDataURL("image/png");
}

function image_to_data(imageData) {
	const data = new Array(IMAGE_SIZE * IMAGE_SIZE);
	for (let y = 0; y < IMAGE_SIZE; y++) {
		for (let x = 0; x < IMAGE_SIZE; x++) {
			const ix = Math.floor(x * imageData.width / IMAGE_SIZE);
			const iy = Math.floor(y * imageData.height / IMAGE_SIZE);
			const index = (iy * imageData.width + ix) * 4;
			const r = imageData.data[index + 0];
			const g = imageData.data[index + 1];
			const b = imageData.data[index + 2];
			// Convert to greyscale value (0-1)
			const grey = (r + g + b) / (3 * 255);
			data[y * IMAGE_SIZE + x] = grey;
		}
	}
	return data;	
}

function canvas_to_image_data(canvas) {
	if (!canvas) {
		console.error("No canvas provided for image data conversion");
		return null;
	}
	const imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
	imageData.width = canvas.width;
	imageData.height = canvas.height;
	return imageData;
}

function download() {
	const debugImage = document.getElementById("debugImage");
	if (debugImage) {
		const link = document.createElement("a");
		link.href = debugImage.src;
		// id from YYYYMMDDHHMMSS
		const now = new Date();
		const id = now.getFullYear().toString().padStart(4, '0') +
			(now.getMonth() + 1).toString().padStart(2, '0') +
			now.getDate().toString().padStart(2, '0') +
			now.getHours().toString().padStart(2, '0') +
			now.getMinutes().toString().padStart(2, '0') +
			now.getSeconds().toString().padStart(2, '0');
		link.download = "image_" + id + ".png";
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}

// async function test() {
// 	const data = randomImage();
// 	const result = await recognize(data);
// 	console.log(result);
// }
// test();
async function locally_classify_image(imageData) {
	show_results('üí≠ Thinking...');

	let result = null;
	if (imageData != null) {
		// Convert to normalized form
		const data = image_to_data(imageData);

		// Output debug image
		if (classify_mode) {
			const imageUrl = await data_to_image_url(data);
			if (imageUrl) {
				let debugImage = document.getElementById("debugImage");
				if (!debugImage) {
					debugImage = document.createElement("img");
					debugImage.id = "debugImage";
					debugImage.className = "debug_image";
					debugImage.addEventListener("click", () => { download(); });
					document.body.insertBefore(debugImage, document.body.firstChild);
				}
				debugImage.src = imageUrl;
			}
		}

		result = await recognize(data);
	}
	const results = {
		detected_class: !result ? '' : classes[result.maxIndex],
		class_scores: !result ? [] : result.orderedIndices.map(idx => {
			return {
				class: classes[idx],
				score: result.softmax[idx],
			};
		}),
	};
	show_results(results);
	return results;
}

async function locally_classify_strokes() {
	show_results('üí≠ Redrawing...');

	let imageData = null;
	if (strokes.length > 0) {
		const canvas = rescale_and_draw_to_canvas(strokes);
		imageData = canvas_to_image_data(canvas);
	}

	const results = await locally_classify_image(imageData);
	return results;
}

// ------



let shuffled_classes = [];
let drawing_count = 1;
function next_drawing() {
	classify_mode = false;
	
	// Count correct drawings
	if (drawing_class && recognized_class === drawing_class) {
		drawing_count += 1;
	}

	// Clear image
	clear();

	// Only works if classes are loaded
	if (classes) {
		// If no more shuffled classes are left, reshuffle
		if (!shuffled_classes.length) {
			shuffled_classes = classes.slice();
			// Filter out classes with a '_' prefix
			shuffled_classes = shuffled_classes.filter(c => !c.startsWith('_'));
			// Try to avoid the same class as last time
			for (let retry = 0; retry < 10; retry++) {
				// Shuffle
				for (let i = shuffled_classes.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[shuffled_classes[i], shuffled_classes[j]] = [shuffled_classes[j], shuffled_classes[i]];
				}
				// Check last class
				if (shuffled_classes.length <= 0 || shuffled_classes[0] != drawing_class) break;
			}
		}

		// Remove the first class
		if (shuffled_classes.length > 0) {
			drawing_class = shuffled_classes.shift();
		}
	}

	update_instructions();
}

function update_instructions() {
	const instructionsDiv = document.querySelector(".instructions");
	let message = '-';

	if (!classes) {		// Only if classes are not loaded yet
		message = "(Press 'Start' to begin)";
		document.querySelector("#nextButton").innerText = "‚û°Ô∏è Start";
	} else if (classify_mode) {
		message = 'Classifying mode.';
		document.querySelector("#nextButton").innerText = "‚û°Ô∏è Resume";
	} else if (drawing_class) {
		message = `Drawing ${drawing_count}: <span class="item">${drawing_class}</span>.`;
		if (recognized_class === drawing_class) {
			message += " ‚úÖ";
			document.querySelector("#nextButton").innerText = "‚û°Ô∏è Next";
		} else {
			document.querySelector("#nextButton").innerText = "‚Ü©Ô∏è Skip";
		}
	} else {
		message = 'Draw one of: ' + classes.map(c => `<span class="item">${c}</span>`).join(", ") + '.';
		document.querySelector("#nextButton").innerText = "‚û°Ô∏è Next";
	}
	instructionsDiv.innerHTML = message;
}

function clear() {
	// If debug image exists, remove it
	const debugImage = document.getElementById("debugImage");
	if (debugImage) { debugImage.remove(); }

	const ctx = document.querySelector("canvas").getContext("2d");
	ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	show_results(null);
	strokes.length = 0;
	activeStrokes.clear();
	recognized_class = null;
}

function show_results(results) {
	let prefix = '';
	if (last_error) {
		prefix += `<p class="error">${last_error}</h2>`;
	}
	const resultsDiv = document.querySelector(".results");
	recognized_class = null;
	if (results == null) {
		resultsDiv.innerHTML = prefix + '';
	} else if (typeof results === 'string') {
		resultsDiv.innerHTML = prefix + results;
	} else {
		recognized_class = results.detected_class;
		const correct = recognized_class === drawing_class;
		if (classify_mode) {
			resultsDiv.innerHTML = prefix + `<h2>‚ÑπÔ∏è My guess was: ${recognized_class}</h2>`;
		} else if (!recognized_class) {
			resultsDiv.innerHTML = prefix + `<h2>üò¢ Sorry, I could not guess.</h2>`;
		} else if (correct) {
			resultsDiv.innerHTML = prefix + `<h2>‚úÖ Correct! I guessed it was: ${recognized_class}!</h2>`;
		} else {
			resultsDiv.innerHTML = `<h2>‚ùå Oops, I thought it was: ${recognized_class}.</h2>`;
		}
		const dl = document.createElement("dl");
		const top_k = RESULTS_TOP_K;
		let count = 0;
		for (const item of results.class_scores) {
			if (item.score >= RESULTS_THRESHOLD) {
				let score = (item.score * 100).toFixed(0);
				if (score > 0) {
					let dt = document.createElement("dt");
					dt.textContent = `${item.class}`;
					dl.appendChild(dt);
					let dd = document.createElement("dd");
					dd.textContent = `${score}%`;
					dl.appendChild(dd);
					count += 1;
					if (top_k && count >= top_k) {
						break
					}
				}
			}
		};
		resultsDiv.appendChild(dl);
	}
	update_instructions();
}

async function get_classes() {
	const response = await fetch("./classes.json");
	const result = await response.json();
	console.log("Available classes:", result.classes);
	return result.classes;
}

async function server_classify_strokes() {
	const response = await fetch("./classify_strokes", {
		method: "POST",
		headers: {
			"Content-Type": "application/json"
		},
		body: JSON.stringify({ strokes: strokes })
	});
	const result = await response.json();
	show_results(result);
	return result;
}

async function server_classify_image() {
	const canvas = document.querySelector("canvas");
	const dataURL = canvas.toDataURL("image/png");
	const rawData = dataURL.replace(/^data:image\/png;base64,/, "");
	const response = await fetch("./classify_image_data", {
		method: "POST",
		headers: {
			"Content-Type": "application/json"
		},
		body: JSON.stringify({ image: rawData })
	});
	// Check response code
	if (!response.ok) {
		last_error = `Error: Problem requesting classification from server, returned status ${response.status} (${response.statusText})`;
		show_results();
		return;
	}
	const result = await response.json();
	show_results(result);
	return result;
}

function classify_image(image = null) {
	let canvas = null;
	if (!image) {
		canvas = document.querySelector("canvas");
	} else {
		// Draw image to temporary canvas
		canvas = document.createElement("canvas");
		canvas.width = image.width;
		canvas.height = image.height;
		const ctx = canvas.getContext("2d");
		ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
	}
	const imageData = canvas_to_image_data(canvas);
	if (!imageData) {
		console.error("No image data available for classification");
		return null;
	} else {
		imageData.width = canvas.width;
		imageData.height = canvas.height;
		if (USE_LOCAL_RECOGNIZER) {
			return locally_classify_image(imageData);
		} else {
			return server_classify_image(imageData);
		}
	}
}

function classify_strokes() {
	if (USE_LOCAL_RECOGNIZER) {
		locally_classify_strokes();
	} else {
		server_classify_strokes();
	}
}

document.querySelector("#clearButton").addEventListener("click", (e) => {
	// If shift is pressed
	if (e.shiftKey) {
		classify_mode = true;
	}
	clear();
});
document.querySelector("#classifyStrokesButton").addEventListener("click", () => classify_strokes());
document.querySelector("#classifyImageButton").addEventListener("click", () => classify_image());
document.querySelector("#nextButton").addEventListener("click", () => next_drawing());

function translate_coordinates(x, y) {
	const dpr = window.devicePixelRatio || 1;
	x = (dpr * x - offset_x) / scale;
	y = (dpr * y - offset_y) / scale;
	return [x, y];
}

function startDrawing(pointerId, x, y) {
	const startPoint = translate_coordinates(x, y);
	activeStrokes.set(pointerId, [startPoint]);

	// Clear results while drawing a fresh stroke
	show_results(null);
}

function draw(pointerId, x, y) {
	const currentStroke = activeStrokes.get(pointerId);
	if (!currentStroke) return;
	const point = translate_coordinates(x, y);
	currentStroke.push(point);

	// Draw only the last segment for this stroke
	draw_to_canvas(document.querySelector("canvas"), [currentStroke.slice(-2)], true);
}

function stopDrawing(pointerId) {
	const currentStroke = activeStrokes.get(pointerId);
	if (!currentStroke) return;
	activeStrokes.delete(pointerId);

	if (currentStroke.length > 1) {
		strokes.push(currentStroke);
	}

	// If auto-checking, only classify when all pointers finished
	if (activeStrokes.size === 0 && document.querySelector("#classifyStrokesButton").classList.contains("hidden")) {
		classify_strokes();
	}
}

async function run() {
	if (SHOW_DIALOG) {
		document.querySelector("dialog").showModal();
	}

	// Handle dropped files anywhere on the page
	window.addEventListener("dragover", (e) => {
		e.preventDefault();
	});
	window.addEventListener("drop", async (e) => {
		e.preventDefault();
		if (e.dataTransfer.files.length > 0) {
			const file = e.dataTransfer.files[0];
			const reader = new FileReader();
			reader.onload = async function(event) {
				const img = new Image();
				img.onload = async function() {
					classify_mode = 'image';
					// Draw to canvas
					const canvas = document.querySelector("canvas");
					const ctx = canvas.getContext("2d");
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
					const x = (canvas.width - img.width * scale) / 2;
					const y = (canvas.height - img.height * scale) / 2;
					ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
					// Classify image
					await classify_image(img);
				}
				img.src = event.target.result;
			}
			reader.readAsDataURL(file);
		}
	});

	try {
		classes = await get_classes();
	} catch (e) {
		last_error = 'Error: Problem loading classes: ' + e.reason;
		show_results();
	}
	next_drawing();

	const canvas = document.querySelector("canvas");
	canvas.addEventListener("pointerdown", (e) => {
		if (classify_mode == 'image') {
			classify_mode = true;
			clear();
		}
		canvas.setPointerCapture(e.pointerId);
		startDrawing(e.pointerId, e.offsetX, e.offsetY);
	});
	canvas.addEventListener("pointermove", (e) => {
		draw(e.pointerId, e.offsetX, e.offsetY);
	});
	canvas.addEventListener("pointerup", (e) => {
		stopDrawing(e.pointerId);
		canvas.releasePointerCapture(e.pointerId);
	});
	canvas.addEventListener("pointercancel", (e) => {
		stopDrawing(e.pointerId);
		canvas.releasePointerCapture(e.pointerId);
	});

	// Detect size change and resize canvas
	function resizeCanvas() {
		const rect = document.querySelector("canvas").getBoundingClientRect();
		const dpr = window.devicePixelRatio || 1;
		canvas.width = rect.width * dpr;
		canvas.height = rect.height * dpr;
		const ctx = canvas.getContext("2d");
		console.log("Resized canvas to: ", canvas.width, canvas.height);
		draw_to_canvas(canvas, getStrokesIncludingActive());
	}
	clear();
	resizeCanvas();
	window.addEventListener("resize", resizeCanvas);

	// In local-recognition mode, preload
	if (USE_LOCAL_RECOGNIZER) {
		await recognize(); // Preload model
	}
}

window.addEventListener("error", function(e) {
	last_error = 'Error: Sorry, something unexpected has occurred (unhandled): ' + e.error;
	show_results();
});
window.addEventListener("unhandledrejection", function(e) {
	last_error = 'Error: Sorry, something unexpected has occurred (async rejection): ' + e.reason;
	show_results();
});

document.addEventListener("DOMContentLoaded", run);
</script>
</body>
</html>